#!/usr/bin/env python3
"""
datawall_image_analysis.py

Creates a canvas with:
  - A title
  - The (optionally resized) input image
  - The skeleton mask generated by PlantCV
  - A text line with the total branch length
"""
from plantcv import plantcv as pcv
import cv2
import numpy as np
import os
from PIL import Image, ImageDraw, ImageFont
from skimage.morphology import remove_small_objects
#from datawall_skeleton_test import SkeletonAnalyzer

def make_datawall(data):
    # 0. Settings: target width for the image (-1 to keep original)
    img_width = 1080

    # 1. Fetch the image path
    images = data.get("images", {})
    if not images:
        print("No images provided to datawall.")
        return ""
    img_path = next(iter(images.values()))
    img_path = "testimg.jpg"
    if not os.path.isfile(img_path):
        print(f"Image file not found: {img_path}")
        return ""

    # 2. Open image and optionally resize
    img = Image.open(img_path)
    orig_w, orig_h = img.size
    if img_width != -1 and img_width != orig_w:
        scale = img_width / float(orig_w)
        new_h = int(orig_h * scale)
        img = img.resize((img_width, new_h), Image.LANCZOS)
    img_w, img_h = img.size

    # Step 3: run the metrics analyzer
    analyzer = PlantMetricsAnalyzer(img_path)
    result = analyzer.analyze()
    analysis_path = result['analysis_image']
    area = result['area']
    perimeter = result['perimeter']

    # Step 4: load the analysis image (PIL Image), not the path string
    analysis_img = None
    analysis_w = analysis_h = 0
    if os.path.isfile(analysis_path):
        analysis_img = Image.open(analysis_path)
        analysis_w, analysis_h = analysis_img.size
        # resize if it doesn’t match the main image width
        if (analysis_w, analysis_h) != (img_w, img_h):
            analysis_img = analysis_img.resize((img_w, img_h), Image.NEAREST)
            analysis_w, analysis_h = analysis_img.size
    else:
        print("Analysis image not found; skipping analysis display.")

    # Step 5: prepare fonts, title & footer text
    padding = 20
    try:
        title_font = ImageFont.truetype("arial.ttf", 36)
    except IOError:
        title_font = ImageFont.load_default()
    try:
        info_font = ImageFont.truetype("arial.ttf", 24)
    except IOError:
        info_font = ImageFont.load_default()

    title_text = f"Image Analysis - {os.path.basename(img_path)}"
    footer_text = f"Area: {area} px, Perimeter: {perimeter:.1f} px"

    dummy = ImageDraw.Draw(Image.new("RGB", (10, 10)))
    tb = dummy.textbbox((0, 0), title_text, font=title_font)
    title_h = tb[3] - tb[1]
    fb = dummy.textbbox((0, 0), footer_text, font=info_font)
    footer_h = fb[3] - fb[1]

    # Step 6: compute full canvas size
    canvas_w = img_w
    canvas_h = (
            padding
            + title_h
            + padding
            + img_h
            + padding
            + (analysis_h if analysis_img else 0)
            + padding
            + footer_h
            + padding
    )

    canvas = Image.new("RGB", (canvas_w, canvas_h), color=(255, 255, 255))
    draw = ImageDraw.Draw(canvas)

    # Step 7: draw the title
    tb = draw.textbbox((0, 0), title_text, font=title_font)
    title_w = tb[2] - tb[0]
    draw.text(((canvas_w - title_w) // 2, padding), title_text, font=title_font, fill=(0, 0, 0))

    # Step 8: paste the main image
    y = padding + title_h + padding
    canvas.paste(img, (0, y))

    # Step 9: paste the analysis image underneath
    if analysis_img:
        y += img_h + padding
        canvas.paste(analysis_img.convert("RGB"), (0, y))

    # Step 10: draw the footer
    y += (analysis_h if analysis_img else 0) + padding
    fb = draw.textbbox((0, 0), footer_text, font=info_font)
    footer_w = fb[2] - fb[0]
    draw.text(((canvas_w - footer_w) // 2, y), footer_text, font=info_font, fill=(0, 0, 0))

    # Step 11: save & return
    output_path = os.path.abspath("./analysis_datawall.png")
    canvas.save(output_path)
    return output_path

class PlantMetricsAnalyzer:
    def __init__(self, img_path, out_dir=None):
        self.img_path = img_path
        self.out_dir = out_dir or os.getcwd()

    def analyze(self):
        # 1. Read image
        img_np, _, filename = pcv.readimage(filename=self.img_path)

        # 2. Segment: V‐channel + Otsu
        gray = pcv.rgb2gray_hsv(img_np, 'v')
        mask = pcv.threshold.otsu(gray, object_type='light')

        # 3. Clean: hole‐filling + remove small objects
        mask = pcv.fill_holes(mask)
        # convert to bool, prune, back to 0/255 uint8
        mask_bool = mask.astype(bool)
        cleaned = remove_small_objects(mask_bool, min_size=500)
        mask = (cleaned.astype("uint8")) * 255

        # 4. Area = pixel count
        area = int(np.sum(mask > 0))

        # 5. Contours → perimeter
        contours, _ = cv2.findContours(mask.copy(),
                                       cv2.RETR_EXTERNAL,
                                       cv2.CHAIN_APPROX_SIMPLE)
        perimeter = float(sum(cv2.arcLength(cnt, True) for cnt in contours))

        # 6. Annotate on the original
        img_pil = Image.open(self.img_path).convert("RGB")
        draw = ImageDraw.Draw(img_pil)

        # draw outline in green
        for cnt in contours:
            pts = [tuple(pt[0]) for pt in cnt]
            if pts:
                pts.append(pts[0])
                draw.line(pts, fill=(0,255,0), width=3)

        # draw text in red
        try:
            font = ImageFont.truetype("arial.ttf", 24)
        except IOError:
            font = ImageFont.load_default()
        text = f"Area: {area} px\nPerimeter: {perimeter:.1f} px"
        draw.multiline_text((10, 10), text, font=font, fill=(255,0,0))

        # 7. Save & return
        out_name = f"metrics_{filename}"
        out_path = os.path.join(self.out_dir, out_name)
        img_pil.save(out_path)

        return {
            'analysis_image': out_path,
            'area': area,
            'perimeter': perimeter
        }

class SkeletonAnalyzer:
    def __init__(self, img_path, out_dir=None):
        """
        :param img_path: path to the source image
        :param out_dir: where to write outputs (defaults to cwd)
        """
        self.img_path = img_path
        self.out_dir = out_dir or os.getcwd()

    def analyze(self):
        # Ensure we have a label to grab outputs under
        pcv.params.sample_label = "plant"

        # 1. Read image
        img, _, filename = pcv.readimage(filename=self.img_path)

        # 2. Convert to grayscale (value channel) & simple binary threshold
        gray = pcv.rgb2gray_hsv(img, 'v')
        mask = pcv.threshold.binary(gray, 85, object_type='light')

        # 3. Clean it up
        mask = pcv.fill_holes(mask)
        #mask = pcv.threshold.otsu(gray, max_value=255, object_type='light')
        lab_a = pcv.rgb2gray_lab(img, 'a')
        mask = pcv.threshold.binary(lab_a, 128, object_type='light')

        pcv.visualize.histogram(gray)

        # 4. Skeletonize
        skeleton = pcv.morphology.skeletonize(mask)

        # 5. Break into segments
        segmented_img, segments = pcv.morphology.segment_skeleton(skel_img=skeleton,
                                                                 mask=mask)

        # 6. Measure each segment’s path length (geodesic)
        labeled_img = pcv.morphology.segment_path_length(segmented_img=segmented_img,
                                                         objects=segments)

        # 7. Pull out the lengths from pcv.outputs
        lengths = pcv.outputs.observations['plant']['segment_path_length']['value']
        total_length = sum(lengths)

        # 8. Save the visualized skeleton+lengths image
        out_fname = f"skeleton_{filename}"
        out_path = os.path.join(self.out_dir, out_fname)
        Image.fromarray(labeled_img).save(out_path)

        return {
            'skeleton_image': out_path,
            'total_branch_length': total_length
        }